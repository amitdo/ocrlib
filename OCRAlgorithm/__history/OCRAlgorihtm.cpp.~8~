//C-
//C- This software is subject to, and may be distributed under, the
//C- GNU General Public License, either Version 2 of the license,
//C- or (at your option) any later version. The license should have
//C- accompanied the software or you may obtain a copy of the license
//C- from the Free Software Foundation at http://www.fsf.org .
//C-
//C- This program is distributed in the hope that it will be useful,
//C- but WITHOUT ANY WARRANTY; without even the implied warranty of
//C- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//C- GNU General Public License for more details.
//C-

#include "OCRAlgorihtm.h"

namespace ocr{

// ----- constructor and destructor
//________OCRFilter_________________
OCRFilter::~OCRFilter(){}

OCRFilter::OCRFilter(int ncnr){
	szf=sizeof(int);            // szf=4;

	ImBuf=(int*)malloc((ncnr+512+16)*szf);
	ReBuf=(int*)malloc((ncnr+512+16)*szf);
	BufIn=(int*)malloc((ncnr+512+16)*szf);
	BufOu=(int*)malloc((ncnr+512+16)*szf);
///////////////////////////////////////

  // выход в случае отсутствия свободной памяти запрашиваемого размера
  if (ImBuf==NULL) {DM("ImBuf");exit (1);}
  if (ReBuf==NULL) {DM("ReBuf");exit (1);}
  if (BufIn==NULL) {DM("BufIn");exit (1);}
  if (BufOu==NULL) {DM("BufOu");exit (1);}
}


//-------------------------------АЛГОРИТМЫ------------------------------------//

// -----------------------------------------------------------------------------
// ++++++
// ФИЛЬТР НИЗКИХ ЧАСТОТ  (ГАУССИАН - Gaussian), попытка минимальной реализации.

// Адаптивный F(KHig) нолевой бордюр вокруг массивов.

// 2 массива

// -----------------------------------------------------------------------------

	// треугольная весовая функция

	// y(n)= -y(n-2)+2y(n-1)+x(n-2k-2)-2x(n-k-1)+xn


 void OCRFilter::filterHigh(vector<int> &In, int KHig){
 int y,Khg;
 short size=In.size();

//////////////////////////////////////////////  всего 2 массива

 if ( KHig<2 ) KHig=1;   if ( KHig>80 ) KHig=80;   // if ( KHig>63 ) KHig=63;
 // для фильтра низких частот  KhgN=KHig*N+1 ,  при KHig=64 :
 //      129           257             385
 int  s2=KHig*2+1,  s4=KHig*4,    s6=KHig*6+1;

// vector<int> BufIn(size+s6);
// vector<int> lt1(size+s6);
// int BufIn[10000]={0};
// int lt1[10000]={0};

	  // обнуление ImBuf,ReBuf ( где ImBuf,ReBuf глобальные )
	  memset(ImBuf,0,4*(ncnr+512));      memset(ReBuf,0,4*(ncnr+512));
	  //for ( y=0; y < size+s6; y++ ){BufIn[y]=lt1[y]=0;}

	  // Входной буфер BufIn[y+s2], In[y]
	  for ( y=0; y < size; y++ ){ImBuf[y+s2]=In[y];}
	  Khg=KHig*KHig;
	  for ( y=s2; y < size+s4; y++ ) { //прямоугольная весовая функция, прямая фильтрация
		 ReBuf[y]=-ReBuf[y-2]+2*ReBuf[y-1]+ImBuf[y-KHig-KHig]-2*ImBuf[y-KHig]+ImBuf[y]; //k=15+
	  }
	  for ( y=s2; y < size+s4; y++ ) { ReBuf[y]=ReBuf[y]/Khg;  ImBuf[y]=0; } // Norm // y=0; size+s6;
	  // memset(ImBuf,0,4*(ncnr+512));
	  for ( y=size+s4; y > s2; y-- ) { //прямоугольная весовая функция, инверсная фильтрация
		 ImBuf[y]=-ImBuf[y+2]+2*ImBuf[y+1]+ReBuf[y+KHig+KHig]-2*ReBuf[y+KHig]+ReBuf[y];//k=15-
	  }
	  for ( y=s2; y < size+s2; y++ ) { In[y-s2]=ImBuf[y]/Khg; }
	  // Выходной буфер In[y-s2]
/**/

}//_____________________________________________________________________________





};
