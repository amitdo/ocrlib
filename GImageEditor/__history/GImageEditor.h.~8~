//C-
//C- This software is subject to, and may be distributed under, the
//C- GNU General Public License, either Version 2 of the license,
//C- or (at your option) any later version. The license should have
//C- accompanied the software or you may obtain a copy of the license
//C- from the Free Software Foundation at http://www.fsf.org .
//C-
//C- This program is distributed in the hope that it will be useful,
//C- but WITHOUT ANY WARRANTY; without even the implied warranty of
//C- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//C- GNU General Public License for more details.
//C-

//if ( ImBuf !=NULL ) farfree(ImBuf);  //  освобождение памяти
//q=(тип_q *)farmalloc(n_byte);     // запрос памяти без очистки 0
//q_new=farrealloc(q_old,n_byte);;  // изменение размера блока


#ifndef _GImageEditor_H_
#define _GImageEditor_H_
#include "config.h"

#include <stdlib.h>

#include "OCRTypes.h"
#include "pugixml.hpp"
#include "GBitmap.h"
#include "GBitmapInt.h"
#include "GBitset_.h"
#include "GBitsetMatrix.h"
#include "GBitsetContour.h"
#include "GBitsetOCR.h"
#include "php2stl.h"
#include "tiffio.h"


#ifdef WIN32
#include <Classes.hpp>
#include <Controls.hpp>
#include <StdCtrls.hpp>
#include "ieview.hpp"
#include "imageenview.hpp"
#include "imageenvect.hpp"
#include <vcl.h>
#endif

#pragma hdrstop

using namespace std;
using namespace pugi;

namespace ocr{

class  GImageEditor {
protected:
  GImageEditor(void);
  GImageEditor(int nrows, int ncolumns, int border=0);
  GImageEditor(const GImageEditor *ref);
  GImageEditor(const GImageEditor *ref, int border);
 public:
  virtual ~GImageEditor();
  void destroy(void);
  /** @name Initialization. */
  //@{
  void init();
protected:
public:
		GBitmap *pechaImg, *baseImg;              ///<global bitmap data 
		//GBitmap *pechaImgContour;
		vectorOCR vectorBase[300];   //
		letterBase aliKali;                             ///<main letter OCR base
	    vector<letterBase>aliKaliStore;                   //Array of all letterBase from letterStore
		glyphOCR glyphNew;
		//vector<stringOCR>strArray;                     ///<global array of page string data
		map<string,uniRecord>uniTibTable;
 	    vector<stringOCR>correctionTable; ///vector of all unsertan and hand-checked letters for draw in correction table
	    GLogicProcessor *logicProcessor;
		//commandData inputData;
		unsigned int vectorCount;
		GBitset *setBit;
		GBitsetContour *setContour;
		//GBitsetOCR *setOCR;
		int stringIndex, wordIndex, iLeft,iTop;
		int pechaDataLoaded;
		string mainString;
	    unsigned char hexCode[18991]; //byte to char string hex code
#ifdef WIN32	  
		TIEBitmap *bitmapImg;
#endif	
		short PechaLoaded;
		int print;
		//TmainOCRObject *newOCRObject;
		ofstream c_out;

		static GImageEditor* create(void) {return new GImageEditor;}
      
		void startOCR(commandData *inputData);
	    string readInputAction(commandData *inputData);
	    void startOCR_socket(commandData *inputData);
		void startOCRBatch(commandData *inputData);
	    void startOCRBatch_socket(commandData *inputData);
	    string letterBlockCorrelation(commandData *inputData,unsigned int in);
		void pageToBase(commandData *inputData);
		void imageProcess(commandData *inputData); //main multi praccessor image proccesing batch
	    void proccessImage(commandData *inputData, GBitmap *pechaImg); //image proccesing implementation



		void drawString(int nStr,int border);
		void drawStrArray(commandData *inputData,vector<stringOCR>&strArray,int border);
        void drawStrArrayDebug(commandData *inputData,vector<stringOCR>&strArray, int border);
	    void drawLettersInCorrectionTable(commandData *inputData,int mode);
     	string drawBase(commandData *inputData,string data);
	    string drawLetter(commandData *inputData, unsigned int idNumder);
	    string drawEditLetter(commandData *inputData,unsigned int idNumder);
	    string drawCorrectionTable(commandData *inputData,string data);
     	string drawToString(GBitmap *data);  //send image as JPEG data for HTTP and file operations
	    string drawToTiffString(GBitmap *data); //send image as TIFF GroupFax4 data for HTTP and file operations
	    string drawLetterBlock(commandData *inputData,unsigned int idNumber);
	    string drawEditLetterBlock(commandData *inputData,string &resultOCR, unsigned int idNumber);
	
		void readLetterBase(commandData *inputData);
		void readLetterStore(commandData *inputData);
		void writeLetterBase(commandData *inputData);
		void readStrArray(commandData *inputData,vector<stringOCR>&strArray);
		void writeStrArray(commandData *inputData,vector<stringOCR>&strArray);
	    void writePageXML(commandData *inputData);
 	    void writeLetterStat(commandData *inputData);
		void readPageHTML(commandData *inputData,vector<stringOCR>&strArray);
		void setLetter(commandData *inputData);
	    int setLetterScale(GBitmap *img128, glyphOCR *glyph_);
	    void setLetterFromStore(commandData *inputData, glyphOCR *letter,GBitmap* img128); 
	    string testLetter(commandData *inputData, unsigned int idNumber);
	    int  setCorrelation(GBitmap *img, glyphOCR *glyph,float scale);
		void setBase(commandData *inputData);
	    void readCorrectionTable(commandData *inputData);
		/** This function build letter base from text file of alphabet
		 */ 
	    void buildLetter(commandData *inputData);

		//void LoadImageFromPath(string &imgPath);
		GBitmap* LoadImageData(string &inputPath,bool invert);
	    GBitmap* loadFromTiffString(string &dataStr, bool invert);

		void WriteImageData(GBitmap *data,string &path,bool flip, string &mode);
	    void WriteImageData(GBitmap *data,const char* path, bool invert);
		void WriteImageData(GBitmap *data,string &path, bool invert);
	    void WriteImageData(GBitmapInt *data,string &path, bool invert);
		void WriteImageData(GBitset *data,string &path, bool invert);
	    void WriteImageData(GBitset *data,const char* path, bool invert);
		void WriteColumnsData(GBitmap *data, GBitset *set, int nFrm, string &filePath);
		void WriteSpreadData(GBitmap *data, GBitset *set, int nFrm, string &filePath);
		void RemoveBorder(GBitmap *data, GBitset *set, int pageBorder, string &filePath);

	    void setHex(); //set conversion hex code
			
	           //Start detect scan page rotation. i - angle rotation limit
	           //void detectRotation(short i);

		//void LoadImage_mark();
		//void EncodeDjvuExe(AnsiString filePath);
		//void SavePDFAsDjVu();
		//void blur_aniso(short fileIndex);
		//void LoadDjvu();
		//void SaveDjvuExe(TStringList *fileList);
		//void EncodeDjvu(AnsiString filePath);
		//void collectDjvu();
		//void LoadDjvuExe();
};
};
// ---------------- IMPLEMENTATION
# endif

