// ----- constructor and destructor

GBitsetMatrix::~GBitsetMatrix()
{
//if ( data_size !=0 ) {farfree(bits_data);
//drawData->destroy();
//delete drawData;
//}
//line->destroy();
//delete line;
}

void
GBitsetMatrix::destroy(void)
{
if ( data_size !=0 ) {
#ifdef WIN32
	farfree(bits_data);
#else
	free(bits_data);
#endif
	
//drawData->destroy();
//delete drawData;
drawDataRGB->destroy();
delete drawDataRGB;

		   //  освобождение памяти
		   //if ( ImBuf !=NULL ) farfree(ImBuf);
		   //if ( ReBuf !=NULL ) farfree(ReBuf);
		   //if ( BufIn !=NULL ) farfree(BufIn);
		   //if ( BufOu !=NULL ) farfree(BufOu);

		     //  освобождение памяти
#ifdef WIN32
	      if ( srcInt !=NULL ) farfree(srcInt);
		  if ( sInt !=NULL ) farfree(sInt);
		  if (c_out !=NULL ) c_out.close();
#else
	if ( srcInt !=NULL ) free(srcInt);
	if ( sInt !=NULL ) free(sInt);
#endif	
//// освобождение памяти // GBitsetMatrix_base.h  // GBitsetMatrix::destroy(void)

}
}//_____________________________________________________________________________

GBitsetMatrix::GBitsetMatrix()
  : nrows(0), ncolumns(0), border(0), mask32Count(0),
	bits_per_row(0),data_size(0)
{
}

GBitsetMatrix::GBitsetMatrix(int nrows, int ncolumns, int border)
  : nrows(0), ncolumns(0), border(0), mask32Count(0),
	bits_per_row(0),data_size(0)
{
  try
  {
	init(nrows, ncolumns, border);
  }
  catch(int a)
  {
	destroy();
  }
 }


GBitsetMatrix::GBitsetMatrix(const GBitsetMatrix *ref)
  : nrows(0), ncolumns(0), border(0), mask32Count(0),
	bits_per_row(0),data_size(0)
{
  try
  {
	init(ref, ref->border);
  }
  catch(int a)
  {
	destroy();
  }
}

GBitsetMatrix::GBitsetMatrix(const GBitmap *ref, short stepW, short stepH, short flipV)
  : nrows(0), ncolumns(0), border(0), mask32Count(0),
	bits_per_row(0),data_size(0)
{
  try
  {
	init(ref, stepW, stepH, flipV);
  }
  catch(int a)
  {
	destroy();
  }
}


GBitsetMatrix::GBitsetMatrix(const GBitmap *ref, short x, short y, short w, short h, short stepW, short stepH, short flipV)
	: nrows(0), ncolumns(0), border(0), mask32Count(0),
	bits_per_row(0),data_size(0)
{
   try
  {
	init(ref,x,y,w,h, stepW, stepH, flipV);
  }
  catch(int a)
  {
	destroy();
  }

}

GBitsetMatrix::GBitsetMatrix(const GBitsetMatrix *ref, int border)
  : nrows(0), ncolumns(0), border(0), mask32Count(0),
	bits_per_row(0),data_size(0)
{
  try
  {
	init(ref, border);
  }
  catch(int a)
  {
	destroy();
  }
}



// ----- initialization

void
GBitsetMatrix::init(int arows, int acolumns, int aborder)
{
  c_out.open("c://consoleMatrix.txt");
  //c_out<<"start_bit"<<END;
  destroy();
  aborder=aborder+(ncolumns%32)/2; //выравнивание битсета по 32 увеличивает скорость обращения
  nrows = arows + aborder*2;
  ncolumns = acolumns + aborder*2;

	 DM("nrows="<<nrows<<" ncolumns="<<ncolumns<<"arows="<<arows<<" acolumns="<<acolumns<<" aborder"<<aborder<<END);

  border = aborder;
  bits_per_row = ncolumns;
  data_size = (nrows * bits_per_row);
  if (data_size > 0)
	{
#ifdef WIN32
		bits_data=(bool*)farmalloc(data_size);
#else
		bits_data=(bool*)malloc(data_size);
#endif
	  memset (bits_data,0,data_size);
	}

 /* // Размер массивов равен наибольшему из ncolumns и nrows те из ширины и высоты
  ncnr=ncolumns;   // ncnr глобальная
  if ( nrows>=ncolumns ) ncnr=nrows;
  HBuf.resize(ncnr);
  GBuf.resize(ncnr);

  BufS.resize(ncnr);
  BufT.resize(ncnr);
  BufR.resize(ncnr);
  BufL.resize(ncnr);
  BufHelp.resize(ncnr);

  HStr.resize(ncnr);
  HStS.resize(ncnr);
  LStr.resize(ncnr);
  LStS.resize(ncnr);
  data_size=ncolumns*nrows;
*/
  ///////////////////////////////////////
  // запрос памяти с очисткой 0,
  // szf=sizeof(int);         // level.h
  szf=sizeof(int);            // szf=4;
#ifdef WIN32
	srcInt=(unsigned int*)farcalloc(data_size+64, szf);   // переупакованный в int массив пикселей
	sInt=(unsigned int*)farcalloc(data_size+64, szf);   // транспонированый массив
#else
	srcInt=(unsigned int*)malloc((data_size+64)*4);   // переупакованный в int массив пикселей
	sInt=(unsigned int*)malloc((data_size+64)*4);   // транспонированый массив
#endif

  // выход в случае отсутствия свободной памяти запрашиваемого размера
  if (srcInt==NULL) {DM("srcInt==NULL"); exit (1);}
  if (sInt==NULL) {DM("sInt==NULL"); exit (1);}


//  ImBuf=(int*)farcalloc(ncnr+512, szf);
//  ReBuf=(int*)farcalloc(ncnr+512, szf);
//  BufIn=(int*)farcalloc(ncnr+512, szf);
//  BufOu=(int*)farcalloc(ncnr+512, szf);
///////////////////////////////////////

  // выход в случае отсутствия свободной памяти запрашиваемого размера
//  if (ImBuf==NULL) {DM("ImBuf");exit (1);}
//  if (ReBuf==NULL) {DM("ReBuf");exit (1);}
//  if (BufIn==NULL) {DM("BufIn");exit (1);}
//  if (BufOu==NULL) {DM("BufOu");exit (1);}

}

void
GBitsetMatrix::init(const GBitsetMatrix *ref, int aborder)
{
  if (this != ref)    //Учесть aborder
	{
	  init(ref->nrows, ref->ncolumns, aborder);
	  bool *row = bits_data;
	  bool *rowDest;
	  for (int n=0; n<nrows; n++, row+=bits_per_row){
		rowDest=bits_data+bits_per_row*n;
		memcpy( (void*)row, (void*)rowDest,  (ncolumns+border*2)/8 );
	  }
	}
  //else if (aborder > border)
  //	{
  //	  minborder(aborder);
  //	}
	data_size=(ncolumns+border*2)*(nrows+border*2);
 // #define B BitsBuf

}



// Fills a bitmap with the given value
void
GBitsetMatrix::fill(bool value)
{
  for(unsigned int y=0; y<rows(); y++)
	{
	  bool* bm_y = (*this)[y];
	  for(unsigned int x=0; x<columns(); x++)
		bm_y[x] = value;
	}
}


void GBitsetMatrix::setMask(GBitMask32 *srcMask, int maskSize){
	//memcpy(mask32[mask32Count].On, srcMask[0].On,128); //128=32*4
	//mask32[mask32Count]->status=srcMask->status;
	mask32[mask32Count]=srcMask;
	//printMask(mask32[mask32Count],c_out);
}//_____________________________________________________________________________



#ifndef NDEBUG
void
GBitsetMatrix::check_border() const
{int col ;
  if (bits_data)
	{
	  const bool *p = (*this)[-1];
	  for (col=-border; col<ncolumns+border; col++)
		if (p[col])exit(0);
	  for (int row=0; row<nrows; row++)
		{
		  p = (*this)[row];
		  for (col=-border; col<0; col++)
			if (p[col])exit(0);
		  for (col=ncolumns; col<ncolumns+border; col++)
			if (p[col])exit(0);
		}
	}
}
#endif

